### -----------------------------------------------------------------
"""
Module : evoOps

Provides a main function propagate, which takes in a ranked population
(a list of tuples pairing individuals with their fitness rating) and
returns a list of the next generation

Author : AHilton
"""
### -----------------------------------------------------------------

import random
import itertools
import math
import grammar as gram
from grammar.runcontroller import opMap

### ==========================
###    Evolution Parameters
### ==========================

# the percentage of individuals that are selected for reproduction
ELITISM = 1/2
# the ratio of offspring that are created through uniform-crossing
UCROSS_RATE = 1/3
# the rate of coarse mutation (the changing of a grammar operation)
COARSE_MUTATION = 1/20
# the rate of fine mutation (the changing of a parameter)
FINE_MUTATION = 1/10

###
# the main method of the propagate module.  Takes in a ranked population
# and returns the resulting population generated by random reproductions
# of the most fit members of the parent population
###
def propagate(rankedPop):
    popSize = len(rankedPop)
    rankedPop.sort(key=lambda pair: pair[1],reverse=True)
    cutoff = int(popSize * ELITISM)
    rankedParents = rankedPop[:cutoff]
    selectWeights = list(itertools.accumulate([ind[1] for ind in rankedParents]))
    pool = [ind[0] for ind in rankedParents]
    newPop = []
    #operList = [uniformCross,mutate]
    while len(newPop) < popSize:
        children = produceOffspring(pool,selectWeights)
        if not childrenInPop(children,newPop):
            newPop.extend(children)
    return newPop[:popSize]

###
# picks a random operation and applies it to the pool of parents
###
def produceOffspring(pool,weights):
    operChoice = random.random()
    if operChoice <= UCROSS_RATE:
        oper = uniformCross
    else:
        oper = mutate
    return oper(pool,weights)

###
# Uniform Crossing
# goes through the locuses of the genotype of 2 parents A,B and returns
# AxB and BxA
###
def uniformCross(pool,selectWeights):
    parentA,parentB = selectTwo(pool,selectWeights)
    return uCross_genes(parentA,parentB)

###
# uCross_genes
# does a uniform cross of the genes of two parent individual to produce 2 offspring
###
def uCross_genes(parentA,parentB):
    A_genes = parentA.genotype()
    B_genes = parentB.genotype()
    done = False
    while not done:
        AxB_genes = {}
        BxA_genes = {}
        for key in A_genes.keys():
            flip = random.randint(0,1)
            if flip == 0:
                AxB_genes[key] = A_genes[key]
                BxA_genes[key] = B_genes[key]
            else:
                AxB_genes[key] = B_genes[key]
                BxA_genes[key] = A_genes[key]
            AxB = makeGrammarRun(AxB_genes)
            BxA = makeGrammarRun(BxA_genes)
            done = areClones(AxB,BxA,parentA,parentB)
    return [AxB,BxA]
    

###
# Mutation
# goes through all of the locuses of an individual and applies a small chance
# to change either the production operation (coarse mutation) and the parameter
# list (fine mutation)
###
def mutate(pool,selectWeights):
    parent = selectOne(pool,selectWeights)
    pGenes = parent.genotype()
    childGenes = mutate_genotype(pGenes)
    child = makeGrammarRun(childGenes)
    return [child]

###
# returns a mutated form of the genotype
###
def mutate_genotype(pGenes):
    childGenes = {}
    labelPool = list(pGenes.keys())
    for gene in pGenes.items():
        lhs = gene[0]
        gene_prime = (lhs,coarse_mutation(gene,labelPool))
        rhs_prime = fine_mutation(gene_prime,labelPool)
        childGenes[lhs] = rhs_prime
    return childGenes

###
# Coarse Mutation
# applies a chance to change the grammar operation of a given gene, alters the
# parameter list accordingly
###
def coarse_mutation(gene,labelPool):
    flip = random.random()
    if flip <= COARSE_MUTATION:
        rhs = gene[1]
        oldOper = rhs[0]
        newOper = random.choice([op for op in opMap.values() if op is not oldOper])
        if newOper is opMap["rest"]:
            params = ""
        elif newOper is opMap["relabel"]:
            params = random.choice([string for string in labelPool if string is not gene[0]])
        elif newOper is opMap["grow"]:
            params = ""
            for i in range(3):
                params += random.choice(labelPool)
        newGene = (newOper,list(params))
        return newGene
    else:
        return gene[1]

###
# Fine Mutation
# applies a chance to change the parameters of a given gene
# for grow operations it will mutate all 3 parameters
###
def fine_mutation(gene,labelPool):
    flip = random.random()
    if flip <= FINE_MUTATION:
        rhs = gene[1]
        oper = rhs[0]
        curparams = rhs[1]
        if oper is opMap["rest"]:
            params = ""
        elif oper is opMap["relabel"]:
            params = random.choice([string for string in labelPool if string is not curparams])
        elif oper is opMap["grow"]:
            params = ""
            for i in range(3):
                params += random.choice(labelPool)
        newGene = (oper,list(params))
        return newGene
    else:
        return gene[1]
                    

###
# selects one individual from the pool based on the cumulative weights
###
def selectOne(pool,cumWeights):
    selection_idx = selectIndex(cumWeights)
    return pool[selection_idx]

###
# selects two individuals from the pool based on the cumulative weights, without
# duplication
###
def selectTwo(pool,cumWeights):
    A_idx = selectIndex(cumWeights)
    B_pool = pool[:A_idx] + pool[A_idx+1:]
    B_weights = cumWeights[:A_idx] + cumWeights[A_idx+1:]
    B_idx = selectIndex(B_weights)
    selectA = pool[A_idx]
    selectB = B_pool[B_idx]
    return selectA,selectB

###
# returns a weighted, random list index
###
def selectIndex(cumWeights):
    select = random.uniform(0,max(cumWeights))
    i = -1
    done = False
    while i < len(cumWeights) and not done:
        i += 1
        done = select <= cumWeights[i]
    return i

###
# takes in a genotype and produces a GrammarRun object
###
def makeGrammarRun(genotype):
    genotype["none"] = (opMap["rest"],[])
    run = gram.GrammarRun()
    faces = gram.facebuilder.buildDefaultTetra()
    run.setup(genotype,faces)
    return run

###
# takes in 2 lists of GrammarRuns and returns a boolean indicating whether or
# not the first list contains an element of the second list
###
def childrenInPop(childList,popList):
    i = 0
    done = False
    while i < len(childList) and not done:
        done = childList[i].genotype() in [g.genotype() for g in popList]
        i += 1
    return done

###
# determines whether or not 2 children match their parents
###
def areClones(AxB,BxA,parentA,parentB):
    return set([AxB.grammarString(),BxA.grammarString()]) == set([parentA.grammarString(),parentB.grammarString()])
